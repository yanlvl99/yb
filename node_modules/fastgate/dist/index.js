/* Nyro */
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);

// src/services/router.ts
var import_nyro = __toESM(require("nyro"));
var ProxyRouter = class {
  constructor() {
  }
  /**
   * @param url URL to send the request to
   * @param method HTTP method to use
   * @returns Promise<any>
   * @description Send a request to a URL
   */
  static async send(url, method) {
    return new Promise((resolve, reject) => {
      (0, import_nyro.default)({
        url,
        method,
        headers: {
          "Content-Type": "application/json",
          "Accept": "*/*"
        },
        timeout: 1e4
      }).then((response) => {
        resolve(response.body);
      }).catch((error) => {
        reject(error);
      });
    });
  }
};

// src/services/engine.ts
var cachedProxies = [];
var lastFetchTimestamp = 0;
var Engine = class {
  constructor() {
  }
  static {
    this.proxies = cachedProxies;
  }
  /**
   * Get a list of proxies
   * @param options Options for fetching the list
   * @returns ProxyAPIResponse
   * 
   * @example
   * 
   * import fastgate from 'fastgate';
   * 
   * fastgate.getProxyList({
   *    country: ['US'],
   *    protocol: ['http'],
   *    anonymity: ['elite'],
   *    timeout: 5000
   * }).then((response) => {
   *  console.log(response);
   * })
   * 
   */
  static async getProxyList(options) {
    if (!options) options = {};
    if (!options.format) options.format = "json";
    if (!options.proxy_format) options.proxy_format = "protocolipport";
    if (!options.protocol) options.protocol = ["http", "socks4", "socks5"];
    return new Promise((resolve, reject) => {
      ProxyRouter.send(
        `https://api.proxyscrape.com/v4/free-proxy-list/get?request=display_proxies${options.country ? `&country=${options.country.join(",")}` : ""}${options.protocol ? `&protocol=${options.protocol.join(",")}` : ""}${options.proxy_format ? `&proxy_format=${options.proxy_format}` : ""}${options.format ? `&format=${options.format}` : ""}${options.anonymity ? `&anonymity=${options.anonymity.join(",")}` : ""}${options.timeout ? `&timeout=${options.timeout}` : ""}`,
        "GET"
      ).then((response) => {
        resolve(response);
      }).catch((error) => {
        reject(error);
      });
    });
  }
  /**
   * Get a proxy from the list
   * @param fetchOptions Options for fetching the proxy
   * @returns ProxyObject
   * 
   * @example 
   * 
   * import fastgate from 'fastgate';
   * 
   * fastgate.getProxy({
   *    force: false,
   *   proxyOptions: {
   *      alive: true,
   *     timeout: (timeout) => {
   *      return timeout < 5000;
   *    },
   *     ip: (ip) => {
   *        return ip.startsWith('190');
   *    }
   * }).then((response) => {
   *  console.log(response);
   * })
   * 
   */
  static async getProxy(fetchOptions) {
    if (!fetchOptions) fetchOptions = {};
    if (fetchOptions?.force) cachedProxies = [];
    if (fetchOptions?.reload && fetchOptions?.reloadTimeout && Date.now() - lastFetchTimestamp > fetchOptions?.reloadTimeout) {
      cachedProxies = [];
    }
    const filteredCatchProxy = () => {
      const findedProxy = cachedProxies.find((proxy) => {
        if (fetchOptions?.proxyOptions?.alive && !proxy?.alive) return false;
        if (fetchOptions?.proxyOptions?.timeout && !fetchOptions.proxyOptions.timeout(proxy.timeout)) return false;
        if (fetchOptions?.proxyOptions?.anonymity && !fetchOptions.proxyOptions.anonymity.includes(proxy.anonymity)) return false;
        if (fetchOptions?.proxyOptions?.protocol && !fetchOptions.proxyOptions.protocol.includes(proxy.protocol)) return false;
        if (fetchOptions?.proxyOptions?.ssl !== void 0 && proxy?.ssl !== fetchOptions.proxyOptions.ssl) return false;
        if (fetchOptions?.proxyOptions?.ip && !fetchOptions.proxyOptions.ip(proxy.ip)) return false;
        if (fetchOptions?.proxyOptions?.port && !fetchOptions.proxyOptions.port(proxy.port)) return false;
        return true;
      });
      return findedProxy;
    };
    const catchProxy = () => {
      if (cachedProxies.length === 0) {
        throw new Error("No proxies found");
      }
      ;
      var randomNumber = Math.floor(Math.random() * cachedProxies.length);
      var proxy = cachedProxies[randomNumber];
      if (fetchOptions?.removeProxy) cachedProxies.splice(randomNumber, 1);
      return proxy;
    };
    if (cachedProxies.length === 0) {
      cachedProxies = await new Promise((resolve, reject) => {
        this.getProxyList().then((response) => {
          lastFetchTimestamp = Date.now();
          if (!response.proxies) {
            reject("No proxies found");
            return;
          }
          resolve(response.proxies);
        }).catch((error) => {
          reject(error);
        });
      });
      if (fetchOptions.proxyOptions) {
        return filteredCatchProxy();
      } else {
        return catchProxy();
      }
    } else {
      if (fetchOptions.proxyOptions) {
        return filteredCatchProxy();
      } else {
        return catchProxy();
      }
    }
  }
};

// src/index.ts
var src_default = Engine;
/* Nyro */
//# sourceMappingURL=index.js.map